1. this
   Each object gets copy of their data segment but static data and member function segment
   remain same for each object.
   So, calling a function using obj.func() syntax complier provide a hidden pointer to object
   which is this.
   In case of const member function, it is cosnt * this.
   this pointer is not passed to static member function.

2. new
   Allocate the memory in heap and then return the pointer for type T.
   T *ptr= new T(val1, val2);

3. delete
   used to deallocate the memory which is allocated dynamically.
   delete ptr;
   deallocate memory pointed by ptr not ptr.

4. static
   -> static objects/variable deleted after end of program and defined only once, but their scope
   -> is like noraml variable(local/global).
   -> static member of a class is same for each object.
   -> Can be declared public , private or ptrotected.
   -> static data member must be defined using :: operator outside class.
   -> static member function can acces only static data member.
   -> non static member function can also acces static data member.
   -> static member can also be accesed using :: operator.

5. const
   -> any variable/method/object declared as const doesn't allow  to change value in it.
   -> const int var=10;   // must be initialised with cosnt.
   -> const ClassName obj(); // declaration of const object.
   -> void fun() const {}  // declaration of const function.
   -> a const object can only call const member function.
   -> a const member function can be called by non const function, but in can not modify value inside.

6. final
    -> class ClassName final {} // Now this class can not be inherited.
    -> virtual void func(args) final {} // Now this method can not be override by sub class.

7. explicit
  -> If a Constructor has zero required args then it will work as implicit conversion operator.
  to prevent that prefix explicit to the Constructor like
  explicit ClassName() {}

8. virtual
   -> class Derived: virtual public Base {}
   Now base class Constructor will be called only once.

   -> virtual void func(args) {} // This method can be override by derived class and calling of the method decided at run time
   depending on content of pointer/reference.

9. freind
   -> freind return_type func(args);
   // A function defined as freind inside a class has acces all members of that class.
   // static members can be accesed using class::member;
   // to acces object's member, has to pass the object as argument to func and then it can acces all member of obj.
   // This is a noraml function, so it's declaration does'nt depend on acces specifiers.
   // freindship in not mutual, not symmetric, nor transitive.

   -> freind class className;
   // all the member function of className has acces to private and protected members of class in which this declaration has made.

   -> use in defining a function which need to acces the private members of two class like operator overloading.

10. inline 
   -> inline return_type func(args){}
   // This definition request complier to replace this function definition at the position it get called, instead of calling this.
   // complier may or may not approve this request.
   // by defalut all member function defined inside a class is inline.
   // useful in short functions. 

11. override
    void func() override;
    Ensures that a virtual function is present in base class with same signature.

